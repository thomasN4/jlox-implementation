[[file:ch13challenges.png]]

1. I'll implement traits. These seem to come with less problems than multiple inheritance or mixins (no diamond problem or unexpected behavior when modifying parent classes), while providing a good amount of code reusability.

   Grammar: traitDecl -> "trait" IDENTIFIER "{"
                         ( ( "default" function ) |
                           ( IDENTIFIER "(" parameters? ")" ";" ) )* "}" ;
            classDecl -> "class" IDENTIFIER ( "<" IDENTIFIER )? "(" parameters ")"
                         "{" ( function | getterMethod | staticMethod )* "}" ;

   Suppose there is a class A implementing trait B. Class A must implement any methods of B that don't have a default implementation (which are denoted by a `default` modifier in front of their name). The method implementations in A don't need their parameters to have the same names as defined in B (thus only the arity should be the same). Can checking the proper implementation of B's methods in A be done statically (in the Resolver)? Yes. Since B has to be visited by the Resolver by the time it gets to A, we could 

2. 
